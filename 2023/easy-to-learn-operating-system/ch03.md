# Chapter 03 프로세스와 스레드

- 키워드
    - 프로세스, 프로그램, 시분할 방식 시스템, 프로세스 제어 블록, 문맥 교환, 스레드,
- 질문 만들기
    - 프로그램과 프로세스의 차이는?
    - 운영체제의 운영 기법 중 일괄 처리 시스템과 시분할 시스템에 대해서 설명하세요.
    - 프로세스의 상태에 대해서 설명하세요.
    - 프로세스 상태 전이 중 디스패치와 타임아웃에 대해서 설명하세요.
    - 활성 상태 외의 프로세스 상태의 종류
    - PCB의 개념과 구성 요소는?
    - 문맥 교환의 의미는?
    - 문맥 교환의 절차에 대해서 설명하세요.
    - 문맥 교환이 일어나는 상황에 대해서 설명하세요.
    - 문맥 교환과 타임 슬라이스의 크기에 대해서 설명하세요.
    - 프로세스의 구조
    - 사용자가 프로그램을 실행하면?
    - fork() 시스템 호출의 개념과 동작 과정
    - fork() 시스템 호출의 프로세스의 변화
    - 프로세스를 새로 만들지 않고 fork() 시스템 호출의 장점
    - exec() 시스템 호출의 개념과 동작 과정
    - exec() 시스템 호출의 프로세스 변화
    - 고아프로세스와 좀비프로세스

  ### 04 스레드

    - 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU 멀티스레드 정의
    - 멀티스레드와 멀티태스킹 차이
    - 멀티스레드의 장단점
- 질문 답안
    - 프로그램과 프로세스의 차이는?
        - 프로그램은 저장 장치에 저장된 정적인 상태
        - 프로세스는 실행을 위해 메모리에 올라온 동적인 상태
          - 따라서 프로그램이 실행되면 프로세스가 된다. 그리고 프로그램이 프로세스가 된다는 건 운영체제로부터 PCB를 얻는다는 뜻이다. 프로세스가 종료되면 PCB는 폐기.
    - 폰노이만 구조에서 프로그램이 실행된다는 것은?
      - 해당 코드가 메모리에 올라와서 작업이 진행된다는 의미

    - 운영체제의 운영 기법 중 일괄 처리 시스템과 시분할 시스템에 대해서 설명하세요.
        - 일괄 처리 시스템
            - 초기의 컴퓨터 시스템에서 사용
            - **일정량의 데이터를 모아서 한꺼번에 처리하는 방식**
            - 장점: CPU 유휴시간이 줄어든다.
            - 단점: 반환 시간이 늦다.
            - 프로세스 상태
                - 생성, 실행, 완료
        - 시분할 시스템
            - 한 대의 컴퓨터를 동시에 여러 명의 사용자가 대화식으로 사용하는 방식
            - 처리 속도가 매우 빨라 사용자는 독립적인 시스템을 사용하는 것으로 인식
            - 라운드로빈 방식
                - cpu는 여러 개의 작업을 동시에 수행할 수 없기 때문에, **cpu의 전체 사용 시간을 작은 작업 시간량(time slice)으로 나눠 번갈아가면서 cpu에 할당하여 각 작업을 처리**한다.
                - 장점: 시스템의 효율은 좋아진다.
                - 단점: 각 사용자 입장에서는 반응 속도가 느려질 수 있다.
                - 각 작업의 대한 응답 시간을 최소화하는 것을 목적으로 한다.
            - 프로세스 상태
                - 생성
                - 준비
                - 실행
                - 완료
    - 프로세스 상태에 대해서 설명하세요
        - 일괄 작업 시스템의 프로세스 상태
            - 생성, 실행, 완료
        - 시분할 시스템의 프로세스 상태
            - 생성
                - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
                - 프로세스 관리를 위해 필요한 프로세스 제어 블록이 생성된다.
            - 준비
                - CPU가 하나인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 자기 실행 순서가 될 때까지 준비 상태에서 기다려야 한다.
            - 실행
                - 준비 상태에 있는 프로세스 중 하나가 CPU을 얻어 실제 작업을 수행하는 상태
                - 만약 주어진 시간을 다 쓰고도 작업이 끝나지 않았다면 준비 상태로 돌아와 다음 차례를 기다린다.
            - 완료
                - 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다.
                - 프로세스 제어 블록 폐기
        - 오늘날의 프로세스 상태
            - 생성
            - 준비
            - 실행
            - 완료
            - 대기
                - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지는 기다리는 상태로 wait status 라고 한다.
                - 대기 상태는 작업의 효율을 높이기위해 만들어짐
                - 이 상태의 프로세스는 입출력 장치 별로 마련된 큐에서 기다린다.
                - 입출력이 완료되면 인터럽트가 발생하고 해당 프로세스를 찾아 PCB를 준비 상태로 이동시킨다.
                - 어떻게 대기 상태에서 준비 상태로 이동할까? **인터럽트** 때문
                    - 인터럽트의 발생원인
                        - 입출력,
                        - 어떤 이벤트에 의해 발생하기도 한다.
    - 프로세스 상태 전이 중 디스패치와 타임아웃에 대해서 설명하세요.
        - 디스패치
            - **준비** 상태의 프로세스를 **실행** 상태로 바꾸는 **CPU의 스케줄러 작업**
        - 타임아웃
            - 프로세스는 자신에게 주어진 하나의 time slice 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는데 이를 타임 아웃이라고 한다.
                - **클록으로부터의 인터럽트**에 의해 타임아웃이 진행된다.
                    - cpu가 일정 시간(타임 슬라이스) 뒤 알려달라고 클록에 요청을 한 결과
    - 활성 상태 외의 프로세스 상태의 종류
        - 활성 상태
            - 생성, 실행, 준비, 대기, 완료 상태
        - 휴식 상태
            - 프로세스가 작업을 **일시적으로** 쉬고 있는 상태
            - 사용하던 데이터가 메모리에 그대로 있고, PCB도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할 수 있다.
        - 보류 상태
            - 구분
                - 대기 상태에서 옮겨진 **보류 대기 상태**
                    - 입출력 완료 시 보류 준비 상태로 옮겨 간다.
                - 준비 상태에서 옮겨진 **보류 준비 상태**
            - 프로세스가 메모리에서 잠시 쫓겨난 상태
            - 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 **스왑 영역**에 임시 보관된다.
            - 예시
                - 메모리가 꽉 차서 프로세스를 메모리 밖으로 내보낼 떄
                - 프로그램에 오류가 발생해서 실행을 미루어야 할 때
                - 바이러스와 같은 악의적인 공격을 하는 프로세스라고 판단될 때
                - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
                - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
        
    - PCB의 개념과 구성 요소는?
        - PCB란?
            - process control block
            - 프로세스를 실행하는데 필요하고 중요한 정보를 보관하는 자료구조
        - 구성 요소
            - 포인터
                - 준비 상태나 대기 상태는 큐로 운영되는데, 이 큐를 구현할 때 포인터를 사용한다.
            - 프로세스 상태
                - 프로세스 상태에는 생성, 준비, 실행, 대기, 보류 준비, 보류 대기, 완료 등의 상태가 있는데 현재 어떤 상태에 있는지를 나타낸다.
            - 프로세스 구분자
                - 운영체제 내에 있는 여러 프로세스를 구분하기 위한 구분자 PID
            - 프로그램 카운터
                - 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값
            - 프로세스 우선순위
                - 우선순위에 따라 PCB들이 여러 줄로 서있다.
                - 우선순위가 높으면 먼저 실행되고, 자주 실행된다.
                - CPU 스케줄러가 준비 상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 프로세스 우선순위를 기준으로 삼는다.
            - 각종 레지스터 정보
                - 이전에 실행할 때 사용한 레지스터의 값을 보관해서 다음에 실행할 수 있기 때문에 레지스터의 중간값을 보관한다.
            - 메모리 관리 정보
                - 프로세스가 메모리 **어디에 있는지** 나타내는 **메모리 위치 정보**,
                - **메모리 보호**를 위해 사용하는 **경계 레지스터 값과 한계 레지스터 값** 등이 저장된다.
            - 할당된 자원 정보
                - 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보를 말한다.
            - 계정 정보
                - 계정 번호, CPU 할당 시간, CPU 사용 시간 등에 대한 정보
            - PPID와 CPID
                - 부모 프로세스 PPID
                - 자식 프로세스 CPID
    - 문맥 교환의 의미
        - CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.
        - 이 때 두 PCB 의 내용이 변경된다.
            - 실행 상태에서 나가는 PCB는 지금까지의 작업 내용 저장
            - 반대로 실행 상태로 들어오는 PCB의 내용으로 CPU가 다시 세팅된다.
    - 문맥 교환의 절차
        - 프로세스 p1과 p2가 있는 상황
        - 1. p1이 자신에게 주어진 시간을 다 사용하여 타임아웃이 되면 p1의 pcb에 현재까지의 작업 결과가 저장되고 p1은 준비 상태로 쫓겨난다.
        - 2. 준비 상태에 있던 p2가 실행 상태로 가면 CPU의 레지스터가 p2의 pcb 값으로 채워져 다음 작업을 하게 된다.
    - 문맥 교환이 일어나는 상황
        - 일반적으로 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생
        - 인터럽트가 걸렸을 때 발생
            - 예를들어, 어떤 프로세스가 자신에게 주어진 **메모리 공간을 넘어가려 한다면** 이는 경계 레지스터의 범위를 넘어가는 것이다.
                - 이때 인터럽트가 발생하여 현재 실행 중인 프로세스의 PCB를 저장한 후 **인터럽트 관리 프로세스**를 실행 상태로 만든다.
                    - 인터럽트 관리 프로세스는 메모리 범위를 넘어선 프로세스를 강제 종료하고 인터럽트 처리를 마치는데 이와 같이 인터럽트 처리를 할 때도 문맥교환이 일어난다.
    - 문맥 교환과 타임 슬라이스의 크기에 대해서 설명하세요.
        - time slice가 큰 경우
            - 한 프로세스의 작업이 끝난 뒤 다른 프로세스의 작업이 이루어질 때까지 긴 시간이 걸려 **작업이 끊겨 보인다.**
        - time slice가 작은 경우
            - 사용자가 여러 프로그램이 동시에 실행되는 것처럼 느낄 것이다.
            - 하지만 시스템의 성능이 떨어진다.
                - 왜냐하면 문맥교환에도 시간이 걸리는데 **문맥교환하는데 시간을 낭비**하여 실제 작업을 못하는 문제가 발생한다.
        - 결론적으로 time slice는 되도록 작게 설정하되 **문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 설정하는 것이 중요하다.**
        
    - 프로세스의 구조
        - 코드 영역
            - 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다.
            - 프로그래머가 작성한 프로그램은 코드 영역에 탑재되며, 읽기 전용으로 처리된다.
        - 데이터 영역
            - 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아 놓은 곳
            - 읽기/쓰기 가능
                - 상수로 선언된 변수는 읽기만 가능
        - 스택 영역
            - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
            - 사용자에게 보이지 않는다.
                - 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이기 때문.
    - 사용자가 프로그램을 실행하면?
        - **운영체제**는 프로그램을 메모리로 가져와 코드 영역에 넣고 **PCB를 생성**한다.
        - 그리고 **메모리에 데이터 영역과 스택 영역을 확보**한 후 **프로세스를 실행**한다.
    - fork() 시스템 호출의 정의
        - 실행 중인 프로세스를 복사하는 함수로 **커널**에서 제공한다.
        - 이때 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 둘은 부모-자식 관계가 된다.
    - fork() 시스템 호출의 프로세스의 변화
        - PCB를 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 단 일부 변경된다.
        - 변경되는 부분
            - 프로세스 구분자 PID
            - 부모 프로세스와 자식 프로세스가 차지하는 메모리의 위치가 다르기 때문에 메모리 관련 정보가 바뀐다.
            - PPID와 CPID가 바뀐다.
    - 프로세스를 새로 만들지 않고 fork() 시스템 호출의 장점
        - 프로세스 생성 속도가 빠르다.
        - 추가 작업 없이 자원을 상속할 수 있다.
            - 부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.
        - 시스템 관리를 효율적으로 할 수 있다.
            - 부모 프로세스와 자식 프로세스가 PPID, CPID로 연결되어 있기 때문에 **자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있다.**
                - 프로세스를 종료하면 프로세스가 사용하던 메모리 영역, 파일, 하드웨어를 정리해야 하는데 이런 정리를 부모 프로세스에 맡김으로써 시스템이 효율적으로 관리된다.
    - exec() 시스템 호출의 정의
        - 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출
        - 현재의 프로세스가 완전히 다른 프로세스로 전환된다.
        - 이미 만들어진 프로세스의 구조를 재활용하는 것
            - 왜? 이미 만들어진 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다. 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월하다.
                - 새로운 프로세스를 만들려면 PCB를 만들고 메모리의 자리를 확보하는 과정이 필요하다. 또한 프로세스를 종료한 후 사용한 메모리를 청소하기 위해 상위 프로세스와 부모-자식 관계를 만들어야 한다.
    - exec() 시스템 호출의 프로세스 변화
        - 기존 프로세스 구조를 그대로 둔 채 내용만 바꾸어 새로 실행하는 것
        - 각종 프로세스 구분자(PID, PPID, CPID)만 남겨두고 프로세스의 나머지 내용을 새로운 것으로 바꾼다.
            - 코드 영역: 새로운 코드, 데이터 영역: 새로운 데이터, 스택은 리셋
    - 고아프로세스와 좀비프로세스
        - 고아 프로세스는 부모 프로세스가 먼저 종료되어 돌아갈 곳이 없는 자식 프로세스를 가리킨다.
        - 좀비 프로세스는 자식 프로세스가 종료되었는데도 부모 프로세스가 뒤처리를 하지 않았을 때 발생한다.
            - 좀비 프로세스가 많아지면 자원이 낭비되기 때문에 효율적인 운영에 방해가 된다.
            - 따라서 운영체제는 주기적으로 반환하지 못한 자원을 회수해야 한다.
    - 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU 멀티스레드 정의
        - 멀티스레드
            - 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
        - 멀티태스킹
            - **운영체제가 CPU에게 작업을 줄 때 시간을 잘게 나누어 배분하는 기법**
            - 이렇게 여러 스레드에 시간을 잘게 나누어 주는 시스템을 시분할 시스템이라고 한다.
                - 시분할 시스템에서 운영체제가 CPU에 전달하는 것은 프로세스가 아니라 스레드다.
        - 멀티프로세싱
            - CPU를 여러 개 사용하여 어러 개의 스레드를 동시에 처리하는 작업 환경
        - CPU 멀티스레드
            - CPU에서 여러 스레드를 동시에 처리하는 것을 CPU 멀티스레드라고 한다.
    - 멀티스레드와 멀티태스킹 차이
        - **멀티태스킹**: 하나의 운영체제 안에서 여러 프로세스가 실행되는 것 (동시에 실행되지 않는다!)
        - **멀티스레드**: 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 **동시에 처리하는 것**
    - 멀티스레드의 장단점
        - 장점
            - 응답성 향상
                - 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 **다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답**할 수 있다.
            - 자원 공유
                - 한 프로세스 내에서 독립적인 스레드를 생성하면 **프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행할 수 있다.**
            - 효율성 향상
                - 여러 개의 프로세스를 생성할 필요가 없어 **불필요한 자원의 중복을 막음**으로써 시스템의 효율이 향상된다.
            - 다중 CPU 지원
                - 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 **다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축**된다.
        - 단점
            - 모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.
                
                → 크롬이 멀티탭 기능을 구현할 때 멀티태스킹을 이용한 이유(
                
                - **다른 스레드가 영향받는 것을 최소화하기 위해** 낭비 요소가 있더라도 멀티스레드 대신 멀티태스킹을 이용
                - 과거와 달리 **요즘은 메모리가 넉넉하고 멀티코어 CPU가 대중화되어 여러 개의 프로세스를 여러 개의 CPU에서 동시에 실행할 수 있게 되었다**.)